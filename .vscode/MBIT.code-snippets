{
	"BIT Template": {
		"scope": "cpp",
		"prefix": "bit",
		"body": [
			"template <typename T>",
			"struct BIT {",
			"    int n;",
			"    std::vector<T> a;",
			"",
			"    BIT(int n = 0) {",
			"        init(n);",
			"    }",
			"",
			"    void init(int n) {",
			"        this->n = n;",
			"        a.assign(n + 1, T());",
			"    }",
			"",
			"    void add(int x, T v) {",
			"        for (int i = x; i <= n; i += i & -i) {",
			"            a[i] += v;",
			"        }",
			"    }",
			"",
			"    T sum(int x) {",
			"        auto ans = T();",
			"        for (int i = x; i > 0; i -= i & -i) {",
			"            ans += a[i];",
			"        }",
			"        return ans;",
			"    }",
			"",
			"    T rangeSum(int l, int r) {",
			"        return sum(r) - sum(l - 1);",
			"    }",
			"",
			"    int kth(T k) {",
			"        int x = 0;",
			"        for (int i = 1 << static_cast<int>(std::log2(n)); i; i /= 2) {",
			"            if (x + i <= n && k >= a[x + i]) {",
			"                x += i;",
			"                k -= a[x];",
			"            }",
			"        }",
			"        return x;",
			"    }",
			"};"
		],
		"description": "C++ BIT (Binary Indexed Tree) 模板代码"
	},
	"DSU Template": {
		"scope": "cpp",
		"prefix": "dsu",
		"body": [
			"struct DSU {",
			"    vector<int> fa, siz;",
			"    DSU(int n) {",
			"        init(n);",
			"    }",
			"",
			"    void init(int n) {",
			"        fa.resize(n + 1);",
			"        iota(fa.begin(), fa.end(), 0);",
			"        siz.assign(n + 1, 1);",
			"    }",
			"",
			"    int find(int x) {",
			"        while (x != fa[x]) {",
			"            x = fa[x] = fa[fa[x]];",
			"        }",
			"        return x;",
			"    }",
			"",
			"    bool same(int x, int y) {",
			"        return find(x) == find(y);",
			"    }",
			"",
			"    bool merge(int x, int y) {",
			"        x = find(x);",
			"        y = find(y);",
			"        if (x == y) {",
			"            return false;",
			"        }",
			"        siz[x] += siz[y];",
			"        fa[y] = x;",
			"        return true;",
			"    }",
			"",
			"    int size(int x) {",
			"        return siz[find(x)];",
			"    }",
			"};"
		],
		"description": "C++ DSU (Disjoint Set Union) 模板代码"
	},
	"ST Template": {
		"scope": "cpp",
		"prefix": "st",
		"body": [
			"template<class T>",
			"struct ST {",
			"    int n, k;",
			"    vector<T> in;",
			"    vector<vector<T>> mx, mi;",
			"",
			"    ST(vector<T> in_) {",
			"        init(in_);",
			"    }",
			"",
			"    void init(vector<T> in_) {",
			"        n = in_.size();",
			"        k = (int)(log2(n)) + 1;",
			"        in = in_;",
			"        mx.assign(k, vector<T>(n, T()));",
			"",
			"        for (int i = 0; i < n; i++) {",
			"            mx[0][i] = in[i];",
			"        }",
			"        for (int j = 1; j < k; j++) {",
			"            for (int i = 0; i + (1 << j) <= n; i++) {",
			"                mx[j][i] = op(mx[j - 1][i], mx[j - 1][i + (1 << (j - 1))]);",
			"            }",
			"        }",
			"    }",
			"",
			"    T query(int l, int r) {",
			"        if (l > r) return T();",
			"        int x = log2(r - l + 1);",
			"        return op(mx[x][l], mx[x][r - (1 << x) + 1]);",
			"    }",
			"",
			"    T op(T a, T b) {",
			"        return gcd(a, b);",
			"    }",
			"};"
		],
		"description": "C++ ST (Sparse Table) 模板代码"
	},
	"SegmentTree Template": {
		"scope": "cpp",
		"prefix": "seg",
		"body": [
			"template<class Info>",
			"struct SegmentTree {",
			"    #define mid ((l+r)/2)",
			"    int n;",
			"    std::vector<Info> node;",
			"    SegmentTree() : n(0) {}",
			"    SegmentTree(int n_, Info v_ = Info()) {",
			"        init(n_, v_);",
			"    }",
			"    template<class T>",
			"    SegmentTree(std::vector<T> init_) {",
			"        init(init_);",
			"    }",
			"    void init(int n_, Info v_ = Info()) {",
			"        init(std::vector(n_, v_));",
			"    }",
			"    template<class T>",
			"    void init(std::vector<T> init_) {",
			"        n = init_.size() - 1;",
			"        node.assign(4 << (int)log2(n + 1), Info());",
			"        std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
			"            if (r == l) return void(node[p] = init_[l]);",
			"            build(2 * p, l, mid);",
			"            build(2 * p + 1, mid + 1, r);",
			"            pushup(p);",
			"        };",
			"        build(1, 0, n);",
			"    }",
			"    void pushup(int p) {",
			"        node[p] = node[2 * p] + node[2 * p + 1];",
			"    }",
			"    void update(int p, int l, int r, int x, const Info &v) {",
			"        if (r == l) return void(node[p] = v);",
			"        if (x <= mid) update(2 * p, l, mid, x, v);",
			"        else update(2 * p + 1, mid + 1, r, x, v);",
			"        pushup(p);",
			"    }",
			"    void update(int p, const Info &v) {",
			"        update(1, 0, n, p, v);",
			"    }",
			"    Info query(int p, int l, int r, int x, int y) {",
			"        if (l >= x && r <= y)",
			"            return node[p];",
			"        if (y <= mid)",
			"            return query(2 * p, l, mid, x, y);",
			"        if (x > mid)",
			"            return query(2 * p + 1, mid + 1, r, x, y);",
			"        return query(2 * p, l, mid, x, y) + query(2 * p + 1, mid + 1, r, x, y);",
			"    }",
			"    Info query(int l, int r) {",
			"        return query(1, 0, n, l, r);",
			"    }",
			"    template<class F>",
			"    int findFirst(int p, int l, int r, int x, int y, F pred) {",
			"        if (l > y || r < x || !pred(node[p])) return -1;",
			"        if (r == l) return l;",
			"        int res = findFirst(2 * p, l, mid, x, y, pred);",
			"        if (res == -1) res = findFirst(2 * p + 1, mid + 1, r, x, y, pred);",
			"        return res;",
			"    }",
			"    template<class F>",
			"    int findFirst(int l, int r, F pred) {",
			"        return findFirst(1, 0, n, l, r, pred);",
			"    }",
			"    template<class F>",
			"    int findLast(int p, int l, int r, int x, int y, F pred) {",
			"        if (l > y || r < x || !pred(node[p])) return -1;",
			"        if (r == l) return l;",
			"        int res = findLast(2 * p + 1, mid + 1, r, x, y, pred);",
			"        if (res == -1) res = findLast(2 * p, l, mid, x, y, pred);",
			"        return res;",
			"    }",
			"    template<class F>",
			"    int findLast(int l, int r, F pred) {",
			"        return findLast(1, 0, n, l, r, pred);",
			"    }",
			"    #undef mid",
			"};",
			"",
			"struct Info {",
			"    int l, r;",
			"    ll sum;",
			"};",
			"",
			"Info operator+(Info a, Info b) {",
			"    return { a.l, b.r, a.sum + b.sum };",
			"}"
		],
		"description": "C++ SegmentTree 模板代码以及 Info 结构体定义"
	},
	"HLD Template": {
		"scope": "cpp",
		"prefix": "hld",
		"body": [
			"struct HLD {",
			"    int n;",
			"    vector<int> siz, top, dep, parent, in, out, seq;",
			"    vector<vector<int>> e;",
			"    int cur;",
			"",
			"    HLD() {}",
			"    HLD(int n) {",
			"        init(n);",
			"    }",
			"    void init(int n) {",
			"        this->n = n;",
			"        siz.resize(n + 1);",
			"        top.resize(n + 1);",
			"        dep.resize(n + 1);",
			"        parent.resize(n + 1);",
			"        in.resize(n + 1);",
			"        out.resize(n + 1);",
			"        seq.resize(n + 1);",
			"        cur = 0;",
			"        e.assign(n + 1, {});",
			"    }",
			"    void addEdge(int u, int v) {",
			"        e[u].push_back(v);",
			"        e[v].push_back(u);",
			"    }",
			"    void work(int root = 0) {",
			"        top[root] = root;",
			"        dep[root] = 0;",
			"        parent[root] = -1;",
			"        dfs1(root);",
			"        dfs2(root);",
			"    }",
			"    void dfs1(int u) {",
			"        if (parent[u] != -1) {",
			"            e[u].erase(std::find(e[u].begin(), e[u].end(), parent[u]));",
			"        }",
			"",
			"        siz[u] = 1;",
			"        for (auto &v : e[u]) {",
			"            parent[v] = u;",
			"            dep[v] = dep[u] + 1;",
			"            dfs1(v);",
			"            siz[u] += siz[v];",
			"            if (siz[v] > siz[e[u][0]]) {",
			"                swap(v, e[u][0]);",
			"            }",
			"        }",
			"    }",
			"    void dfs2(int u) {",
			"        in[u] = ++cur;",
			"        seq[in[u]] = u;",
			"        for (auto v : e[u]) {",
			"            top[v] = v == e[u][0] ? top[u] : v;",
			"            dfs2(v);",
			"        }",
			"        out[u] = cur;",
			"    }",
			"    int lca(int u, int v) {",
			"        while (top[u] != top[v]) {",
			"            if (dep[top[u]] > dep[top[v]]) {",
			"                u = parent[top[u]];",
			"            } else {",
			"                v = parent[top[v]];",
			"            }",
			"        }",
			"        return dep[u] < dep[v] ? u : v;",
			"    }",
			"",
			"    int dist(int u, int v) {",
			"        return dep[u] + dep[v] - 2 * dep[lca(u, v)];",
			"    }",
			"",
			"    int jump(int u, int k) {",
			"        if (dep[u] < k) {",
			"            return -1;",
			"        }",
			"",
			"        int d = dep[u] - k;",
			"",
			"        while (dep[top[u]] > d) {",
			"            u = parent[top[u]];",
			"        }",
			"",
			"        return seq[in[u] - dep[u] + d];",
			"    }",
			"    // u是否是v的祖先",
			"    bool isAncester(int u, int v) {",
			"        return in[u] <= in[v] && in[v] < out[u];",
			"    }",
			"    // 确定在以 u 为根的树中，节点 v 的父节点。",
			"    int rootedParent(int u, int v) {",
			"        std::swap(u, v);",
			"        if (u == v) {",
			"            return u;",
			"        }",
			"        if (!isAncester(u, v)) {",
			"            return parent[u];",
			"        }",
			"        auto it = upper_bound(e[u].begin(), e[u].end(), v, [&](int x, int y) {",
			"            return in[x] < in[y];",
			"        }) - 1;",
			"        return *it;",
			"    }",
			"    // 以 u 为根的树中，节点 v 的子树大小。",
			"    int rootedSize(int u, int v) {",
			"        if (u == v) {",
			"            return n;",
			"        }",
			"        if (!isAncester(v, u)) {",
			"            return siz[v];",
			"        }",
			"        return n - siz[rootedParent(u, v)];",
			"    }",
			"",
			"    int rootedLca(int a, int b, int c) {",
			"        return lca(a, b) ^ lca(b, c) ^ lca(c, a);",
			"    }",
			"};"
		],
		"description": "C++ HLD (Heavy-Light Decomposition) 模板代码"
	},
	"LazySegmentTree Template": {
		"scope": "cpp",
		"prefix": "lseg",
		"body": [
			"template<class Info, class Tag>",
			"struct LazySegmentTree {",
			"    #define mid ((l+r)>>1)",
			"    int n;",
			"    vector<Info> info;",
			"    vector<Tag> tag;",
			"    LazySegmentTree() : n(0) {}",
			"    LazySegmentTree(int n_, Info v_ = Info()) {",
			"        init(n_, v_);",
			"    }",
			"    template<class T>",
			"    LazySegmentTree(vector<T> init_) {",
			"        init(init_);",
			"    }",
			"    void init(int n_, Info v_ = Info()) {",
			"        init(vector<Info>(n_, v_));",
			"    }",
			"    template<class T>",
			"    void init(vector<T> init_) {",
			"        n = init_.size();",
			"        info.assign(4 << (int)log2(n + 1), Info());",
			"        tag.assign(4 << (int)log2(n + 1), Tag());",
			"        function<void(int, int, int)> build = [&](int p, int l, int r) {",
			"            if (l == r) {",
			"                info[p] = init_[l];",
			"                return;",
			"            }",
			"            build(2 * p, l, mid);",
			"            build(2 * p + 1, mid + 1, r);",
			"            pushup(p);",
			"        };",
			"        build(1, 0, n - 1);",
			"    }",
			"    void pushup(int p) {",
			"        info[p] = info[p * 2] + info[p * 2 + 1];",
			"    }",
			"    void apply(int p, const Tag &v) {",
			"        info[p].apply(v);",
			"        tag[p].apply(v);",
			"    }",
			"    void pushdown(int p) {",
			"        apply(2 * p, tag[p]);",
			"        apply(2 * p + 1, tag[p]);",
			"        tag[p] = Tag();",
			"    }",
			"    void update(int p, int l, int r, int x, const Info &v) {",
			"        if (l == r) {",
			"            info[p] = v;",
			"            return;",
			"        }",
			"        pushdown(p);",
			"        if (x <= mid) update(p * 2, l, mid, x, v);",
			"        else update(p * 2 + 1, mid + 1, r, x, v);",
			"        pushup(p);",
			"    }",
			"    void update(int p, const Info &v) {",
			"        update(1, 0, n - 1, p, v);",
			"    }",
			"    Info query(int p, int l, int r, int x, int y) {",
			"        if (l >= x && r <= y)",
			"            return info[p];",
			"        pushdown(p);",
			"        if (y <= mid)",
			"            return query(2 * p, l, mid, x, y);",
			"        if (x > mid)",
			"            return query(2 * p + 1, mid + 1, r, x, y);",
			"        return query(2 * p, l, mid, x, y) + query(2 * p + 1, mid + 1, r, x, y);",
			"    }",
			"    Info query(int l, int r) {",
			"        return query(1, 0, n - 1, l, r);",
			"    }",
			"    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {",
			"        if (l > y || r < x) return;",
			"        if (l >= x && r <= y) {",
			"            apply(p, v);",
			"            return;",
			"        }",
			"        pushdown(p);",
			"        rangeApply(2 * p, l, mid, x, y, v);",
			"        rangeApply(2 * p + 1, mid + 1, r, x, y, v);",
			"        pushup(p);",
			"    }",
			"    void rangeApply(int l, int r, const Tag &v) {",
			"        return rangeApply(1, 0, n - 1, l, r, v);",
			"    }",
			"    template<class F>",
			"    int findFirst(int p, int l, int r, int x, int y, F pred) {",
			"        if (l > y || r < x || !pred(info[p])) return -1;",
			"        if (l == r) return l;",
			"        pushdown(p);",
			"        int res = findFirst(2 * p, l, mid, x, y, pred);",
			"        if (res == -1) res = findFirst(2 * p + 1, mid + 1, r, x, y, pred);",
			"        return res;",
			"    }",
			"    template<class F>",
			"    int findFirst(int l, int r, F pred) {",
			"        return findFirst(1, 0, n - 1, l, r, pred);",
			"    }",
			"    template<class F>",
			"    int findLast(int p, int l, int r, int x, int y, F pred) {",
			"        if (l > y || r < x || !pred(info[p])) return -1;",
			"        if (l == r) return l;",
			"        pushdown(p);",
			"        int res = findLast(2 * p + 1, mid + 1, r, x, y, pred);",
			"        if (res == -1) res = findLast(2 * p, l, mid, x, y, pred);",
			"        return res;",
			"    }",
			"    template<class F>",
			"    int findLast(int l, int r, F pred) {",
			"        return findLast(1, 0, n - 1, l, r, pred);",
			"    }",
			"    #undef mid",
			"};",
			"",
			"struct Tag {",
			"    ll add;",
			"    void apply(Tag t) {",
			"        add += t.add;",
			"    }",
			"};",
			"",
			"struct Info {",
			"    int l, r;",
			"    ll sum;",
			"    void apply(Tag t) {",
			"        sum += t.add * (r - l + 1);",
			"    }",
			"};",
			"",
			"Info operator+(Info a, Info b) {",
			"    return { a.l, b.r, a.sum + b.sum };",
			"}"
		],
		"description": "C++ LazySegmentTree 模板代码以及 Tag、Info 结构体定义"
	},
	"PresidentSegTree Template": {
		"scope": "cpp",
		"prefix": "ptseg",
		"body": [
			"template<class Info>",
			"struct PresidentSegTree {",
			"    #define mid ((l+r)>>1)",
			"    struct node {",
			"        int l, r;",
			"    };",
			"    int cnt, n;",
			"    vector<int> rt;",
			"    vector<node> tr;",
			"    vector<Info> node;",
			"    PresidentSegTree(int n, int q) {",
			"        tr.resize(4 * n + 2 * (log(n) + 1) * q + 500);",
			"        node.resize(4 * n + 2 * (log(n) + 1) * q + 500);",
			"        rt.resize(q + n + 1);",
			"        this->n = n;",
			"        cnt = 0;",
			"    }",
			"    PresidentSegTree(vector<Info> init_, int q) {",
			"        n = init_.size();",
			"        tr.resize(4 * n + 2 * (log(n) + 1) * q + 500);",
			"        node.resize(4 * n + 2 * (log(n) + 1) * q + 500);",
			"        rt.resize(q + n + 1);",
			"        cnt = 0;",
			"        init(init_);",
			"    }",
			"    void pushup(int u) {",
			"        node[u] = node[tr[u].l] + node[tr[u].r];",
			"    }",
			"    void init(vector<Info> init) {",
			"        function<void(int&, int, int)> build = [&](int& u, int l, int r) {",
			"            u = ++cnt;",
			"            if (r == l) {",
			"                node[u] = init[l];",
			"                return;",
			"            }",
			"            build(tr[u].l, l, mid);",
			"            build(tr[u].r, mid + 1, r);",
			"            pushup(u);",
			"        };",
			"        build(rt[0], 0, n - 1);",
			"    }",
			"    void modify(int& u, int v, int l, int r, int x, Info c) {",
			"        u = ++cnt;",
			"        tr[u] = tr[v];",
			"        node[u] = node[v];",
			"        if (l == r) {",
			"            node[u] = c;",
			"            return;",
			"        }",
			"        if (x <= mid) modify(tr[u].l, tr[v].l, l, mid, x, c);",
			"        else modify(tr[u].r, tr[v].r, mid + 1, r, x, c);",
			"        pushup(u);",
			"    }",
			"    // u 版本由 v 版本修改，x位置上的数更新为 c",
			"    void modify(int u, int v, int x, Info add) {",
			"        modify(rt[u], rt[v], 0, n - 1, x, add);",
			"    }",
			"    Info query(int u, int l, int r, int x, int y) {",
			"        if (l >= x && r <= y)",
			"            return node[u];",
			"        if (y <= mid)",
			"            return query(tr[u].l, l, mid, x, y);",
			"        if (x > mid)",
			"            return query(tr[u].r, mid + 1, r, x, y);",
			"        return query(tr[u].l, l, mid, x, y) + query(tr[u].r, mid + 1, r, x, y);",
			"    }",
			"    Info query(int u, int l, int r) {",
			"        return query(rt[u], 0, n - 1, l, r);",
			"    }",
			"    #undef mid",
			"};",
			"",
			"struct Info {",
			"    int x;",
			"};",
			"",
			"Info operator+(Info a, Info b) {",
			"    return { a.x + b.x };",
			"}"
		],
		"description": "C++ PresidentSegTree 模板代码及 Info 结构体定义"
	},
	"HLD + LazySegmentTree 完整模板": {
		"scope": "cpp",
		"prefix": "hldlazy",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"",
			"template<class Info, class Tag>",
			"struct LazySegmentTree {",
			"    #define mid ((l+r)>>1)",
			"    int n;",
			"    vector<Info> info;",
			"    vector<Tag> tag;",
			"    LazySegmentTree() : n(0) {}",
			"    LazySegmentTree(int n_, Info v_ = Info()) {",
			"        init(n_, v_);",
			"    }",
			"    template<class T>",
			"    LazySegmentTree(vector<T> init_) {",
			"        init(init_);",
			"    }",
			"    void init(int n_, Info v_ = Info()) {",
			"        init(vector<Info>(n_, v_));",
			"    }",
			"    template<class T>",
			"    void init(vector<T> init_) {",
			"        n = init_.size();",
			"        info.assign(4 << (int)log2(n + 1), Info());",
			"        tag.assign(4 << (int)log2(n + 1), Tag());",
			"        function<void(int, int, int)> build = [&](int p, int l, int r) {",
			"            if (l == r) {",
			"                info[p] = init_[l];",
			"                return;",
			"            }",
			"            build(2 * p, l, mid);",
			"            build(2 * p + 1, mid + 1, r);",
			"            pushup(p);",
			"        };",
			"        build(1, 0, n - 1);",
			"    }",
			"    void pushup(int p) {",
			"        info[p] = info[p * 2] + info[p * 2 + 1];",
			"    }",
			"    void apply(int p, const Tag &v) {",
			"        info[p].apply(v);",
			"        tag[p].apply(v);",
			"    }",
			"    void pushdown(int p) {",
			"        apply(2 * p, tag[p]);",
			"        apply(2 * p + 1, tag[p]);",
			"        tag[p] = Tag();",
			"    }",
			"    void update(int p, int l, int r, int x, const Info &v) {",
			"        if (l == r) {",
			"            info[p] = v;",
			"            return;",
			"        }",
			"        pushdown(p);",
			"        if (x <= mid) update(p * 2, l, mid, x, v);",
			"        else update(p * 2 + 1, mid + 1, r, x, v);",
			"        pushup(p);",
			"    }",
			"    void update(int p, const Info &v) {",
			"        update(1, 0, n - 1, p, v);",
			"    }",
			"    Info query(int p, int l, int r, int x, int y) {",
			"        if (l >= x && r <= y)",
			"            return info[p];",
			"        pushdown(p);",
			"        if (y <= mid)",
			"            return query(2 * p, l, mid, x, y);",
			"        if (x > mid)",
			"            return query(2 * p + 1, mid + 1, r, x, y);",
			"        return query(2 * p, l, mid, x, y) + query(2 * p + 1, mid + 1, r, x, y);",
			"    }",
			"    Info query(int l, int r) {",
			"        return query(1, 0, n - 1, l, r);",
			"    }",
			"    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {",
			"        if (l > y || r < x) return;",
			"        if (l >= x && r <= y) {",
			"            apply(p, v);",
			"            return;",
			"        }",
			"        pushdown(p);",
			"        rangeApply(2 * p, l, mid, x, y, v);",
			"        rangeApply(2 * p + 1, mid + 1, r, x, y, v);",
			"        pushup(p);",
			"    }",
			"    void rangeApply(int l, int r, const Tag &v) {",
			"        return rangeApply(1, 0, n - 1, l, r, v);",
			"    }",
			"    template<class F>",
			"    int findFirst(int p, int l, int r, int x, int y, F pred) {",
			"        if (l > y || r < x || !pred(info[p])) return -1;",
			"        if (r == l) return l;",
			"        pushdown(p);",
			"        int res = findFirst(2 * p, l, mid, x, y, pred);",
			"        if (res == -1) res = findFirst(2 * p + 1, mid + 1, r, x, y, pred);",
			"        return res;",
			"    }",
			"    template<class F>",
			"    int findFirst(int l, int r, F pred) {",
			"        return findFirst(1, 0, n - 1, l, r, pred);",
			"    }",
			"    template<class F>",
			"    int findLast(int p, int l, int r, int x, int y, F pred) {",
			"        if (l > y || r < x || !pred(info[p])) return -1;",
			"        if (r == l) return l;",
			"        pushdown(p);",
			"        int res = findLast(2 * p + 1, mid + 1, r, x, y, pred);",
			"        if (res == -1) res = findLast(2 * p, l, mid, x, y, pred);",
			"        return res;",
			"    }",
			"    template<class F>",
			"    int findLast(int l, int r, F pred) {",
			"        return findLast(1, 0, n - 1, l, r, pred);",
			"    }",
			"    #undef mid",
			"};",
			"",
			"struct Tag {",
			"    ll add;",
			"    void apply(Tag t) {",
			"        add += t.add;",
			"    }",
			"};",
			"",
			"struct Info {",
			"    int l, r;",
			"    ll sum = 0;",
			"    void apply(Tag t) {",
			"        sum += t.add * (r - l + 1);",
			"    }",
			"};",
			"",
			"Info operator+(Info a, Info b) {",
			"    return { a.l, b.r, a.sum + b.sum };",
			"}",
			"",
			"struct HLD {",
			"    int n;",
			"    vector<int> siz, top, dep, parent, in, out, seq;",
			"    vector<vector<int>> e;",
			"    int cur;",
			"",
			"    HLD() {}",
			"    HLD(int n) {",
			"        init(n);",
			"    }",
			"    void init(int n) {",
			"        this->n = n;",
			"        siz.resize(n + 1);",
			"        top.resize(n + 1);",
			"        dep.resize(n + 1);",
			"        parent.resize(n + 1);",
			"        in.resize(n + 1);",
			"        out.resize(n + 1);",
			"        seq.resize(n + 1);",
			"        cur = 0;",
			"        e.assign(n + 1, {});",
			"    }",
			"    void addEdge(int u, int v) {",
			"        e[u].push_back(v);",
			"        e[v].push_back(u);",
			"    }",
			"    void work(int root = 0) {",
			"        top[root] = root;",
			"        dep[root] = 0;",
			"        parent[root] = -1;",
			"        dfs1(root);",
			"        dfs2(root);",
			"    }",
			"    void dfs1(int u) {",
			"        if (parent[u] != -1) {",
			"            e[u].erase(find(e[u].begin(), e[u].end(), parent[u]));",
			"        }",
			"        siz[u] = 1;",
			"        for (auto &v : e[u]) {",
			"            parent[v] = u;",
			"            dep[v] = dep[u] + 1;",
			"            dfs1(v);",
			"            siz[u] += siz[v];",
			"            if (siz[v] > siz[e[u][0]]) {",
			"                swap(v, e[u][0]);",
			"            }",
			"        }",
			"    }",
			"    void dfs2(int u) {",
			"        in[u] = ++cur;",
			"        seq[in[u]] = u;",
			"        for (auto v : e[u]) {",
			"            top[v] = v == e[u][0] ? top[u] : v;",
			"            dfs2(v);",
			"        }",
			"        out[u] = cur;",
			"    }",
			"    int lca(int u, int v) {",
			"        while (top[u] != top[v]) {",
			"            if (dep[top[u]] > dep[top[v]]) {",
			"                u = parent[top[u]];",
			"            } else {",
			"                v = parent[top[v]];",
			"            }",
			"        }",
			"        return dep[u] < dep[v] ? u : v;",
			"    }",
			"    int dist(int u, int v) {",
			"        return dep[u] + dep[v] - 2 * dep[lca(u, v)];",
			"    }",
			"    int jump(int u, int k) {",
			"        if (dep[u] < k) {",
			"            return -1;",
			"        }",
			"        int d = dep[u] - k;",
			"        while (dep[top[u]] > d) {",
			"            u = parent[top[u]];",
			"        }",
			"        return seq[in[u] - dep[u] + d];",
			"    }",
			"    bool isAncester(int u, int v) {",
			"        return in[u] <= in[v] && in[v] < out[u];",
			"    }",
			"    int rootedParent(int u, int v) {",
			"        swap(u, v);",
			"        if (u == v) {",
			"            return u;",
			"        }",
			"        if (!isAncester(u, v)) {",
			"            return parent[u];",
			"        }",
			"        auto it = upper_bound(e[u].begin(), e[u].end(), v, [&](int x, int y) {",
			"            return in[x] < in[y];",
			"        }) - 1;",
			"        return *it;",
			"    }",
			"    int rootedSize(int u, int v) {",
			"        if (u == v) {",
			"            return n;",
			"        }",
			"        if (!isAncester(v, u)) {",
			"            return siz[v];",
			"        }",
			"        return n - siz[rootedParent(u, v)];",
			"    }",
			"    int rootedLca(int a, int b, int c) {",
			"        return lca(a, b) ^ lca(b, c) ^ lca(c, a);",
			"    }",
			"    auto getPath(int u, int v) {",
			"        vector<pair<int, int>> ret;",
			"        while (top[u] != top[v]) {",
			"            if (dep[top[u]] > dep[top[v]]) {",
			"                ret.push_back({ in[top[u]], in[u] });",
			"                u = parent[top[u]];",
			"            } else {",
			"                ret.push_back({ in[top[v]], in[v] });",
			"                v = parent[top[v]];",
			"            }",
			"        }",
			"        if (dep[u] > dep[v]) swap(u, v);",
			"        ret.push_back({ in[u], in[v] });",
			"        return ret;",
			"    }",
			"    pair<int, int> getTree(int u) {",
			"        return make_pair(in[u], out[u]);",
			"    }",
			"    template<class Tag>",
			"    void modify(int l, int r, const Tag &v);",
			"",
			"    template<class Tag>",
			"    void modify(int root, const Tag &v);",
			"",
			"    template<class Info>",
			"    Info query(int l, int r);",
			"",
			"    template<class Info>",
			"    Info query(int root);",
			"};",
			"",
			"struct Tag {",
			"    ll add;",
			"    void apply(Tag t) {",
			"        add += t.add;",
			"    }",
			"};",
			"",
			"struct Info {",
			"    int l, r;",
			"    ll sum = 0;",
			"    void apply(Tag t) {",
			"        sum += t.add * (r - l + 1);",
			"    }",
			"};",
			"",
			"Info operator+(Info a, Info b) {",
			"    return { a.l, b.r, a.sum + b.sum };",
			"}",
			"",
			"LazySegmentTree<Info, Tag> seg;",
			"",
			"// 修改链",
			"template<class Tag>",
			"void HLD::modify(int l, int r, const Tag &v) {",
			"    while (top[l] != top[r]) {",
			"        if (dep[top[l]] < dep[top[r]]) {",
			"            swap(l, r);",
			"        }",
			"        seg.rangeApply(in[top[l]], in[l], v);",
			"        l = parent[top[l]];",
			"    }",
			"    if (dep[l] > dep[r]) swap(l, r);",
			"    seg.rangeApply(in[l], in[r], v);",
			"}",
			"",
			"// 修改子树",
			"template<class Tag>",
			"void HLD::modify(int root, const Tag &v) {",
			"    seg.rangeApply(in[root], in[root] + siz[root] - 1, v);",
			"}",
			"",
			"// 查询链",
			"template<class Info>",
			"Info HLD::query(int l, int r) {",
			"    Info ans;",
			"    while (top[l] != top[r]) {",
			"        if (dep[top[l]] < dep[top[r]]) {",
			"            swap(l, r);",
			"        }",
			"        ans = ans + seg.query(in[top[l]], in[l]);",
			"        l = parent[top[l]];",
			"    }",
			"    if (dep[l] > dep[r]) swap(l, r);",
			"    return ans + seg.query(in[l], in[r]);",
			"}",
			"",
			"// 查询子树",
			"template<class Info>",
			"Info HLD::query(int root) {",
			"    return seg.query(in[root], in[root] + siz[root] - 1);",
			"}",
			"",
			"void solve() {",
			"    int n, m, s, p;",
			"    cin >> n >> m >> s >> p;",
			"    vector<int> a(n + 1);",
			"    for (int i = 1; i <= n; i++) cin >> a[i];",
			"",
			"    HLD tr(n + 1);",
			"",
			"    for (int i = 1; i < n; i++) {",
			"        int u, v;",
			"        cin >> u >> v;",
			"        tr.addEdge(u, v);",
			"    }",
			"    tr.work(s);",
			"    vector<Info> init(n + 1);",
			"    for (int i = 1; i <= n; i++) {",
			"        init[tr.in[i]] = { tr.in[i], tr.in[i], a[i] };",
			"    }",
			"    seg.init(init);",
			"    ",
			"    while (m--) {",
			"        int op;",
			"        cin >> op;",
			"        if (op == 1) {",
			"            int x, y, z;",
			"            cin >> x >> y >> z;",
			"            tr.modify(x, y, Tag{ z });",
			"        }",
			"        else if (op == 2) {",
			"            int x, y;",
			"            cin >> x >> y;",
			"            cout << tr.query<Info>(x, y).sum % p << endl;",
			"        }",
			"        else if (op == 3) {",
			"            int x, z;",
			"            cin >> x >> z;",
			"            tr.modify(x, Tag{ z });",
			"        }",
			"        else {",
			"            int x;",
			"            cin >> x;",
			"            cout << tr.query<Info>(x).sum % p << endl;",
			"        }",
			"    }",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    solve();",
			"    return 0;",
			"}"
		],
		"description": "C++ HLD 与 LazySegmentTree 整合示例代码，包括模板定义与链/子树的修改查询操作"
	},
	"Mo's Algorithm Template": {
		"scope": "cpp",
		"prefix": "mo",
		"body": [
			"void solve() {",
			"    int n, m;",
			"    cin >> n >> m;",
			"    vector<int> a(n + 1);",
			"    for (int i = 1; i <= n; i++) cin >> a[i];",
			"",
			"    vector<array<int, 3>> query(m + 1);",
			"    vector<int> ans(m + 1);",
			"",
			"    for (int i = 1; i <= m; i++) {",
			"        cin >> query[i][0] >> query[i][1];",
			"        query[i][2] = i;",
			"    }",
			"",
			"    int siz = n / min<int>(n, sqrt(m));",
			"    vector<int> k(n + 1);",
			"    for (int i = 1; i <= n; i++) {",
			"        k[i] = (i - 1) / siz + 1;",
			"    }",
			"",
			"    sort(query.begin() + 1, query.end(), [&](array<int, 3> x, array<int, 3> y) {",
			"        if (k[x[0]] != k[y[0]]) return k[x[0]] < k[y[0]];",
			"        if (k[x[0]] & 1) return x[1] < y[1];",
			"        return x[1] > y[1];",
			"    });",
			"",
			"    vector<int> cnt(n + 1);",
			"    int l = 1, r = 0, val = 0;",
			"    auto add = [&](int x) -> void {",
			"        cnt[a[x]]++;",
			"        if (cnt[a[x]] == 2) val++;",
			"    };",
			"",
			"    auto del = [&](int x) -> void {",
			"        cnt[a[x]]--;",
			"        if (cnt[a[x]] == 1) val--;",
			"    };",
			"",
			"    for (int i = 1; i <= m; i++) {",
			"        auto [ql, qr, idx] = query[i];",
			"",
			"        while (l > ql) add(--l);",
			"        while (r < qr) add(++r);",
			"        while (l < ql) del(l++);",
			"        while (r > qr) del(r--);",
			"        ans[idx] = (val == 0);",
			"    }",
			"",
			"    for (int i = 1; i <= m; i++)",
			"        cout << (ans[i] ? \"Yes\" : \"No\") << endl;",
			"}"
		],
		"description": "莫队算法模板"
	},
	"Block Template": {
		"scope": "cpp",
		"prefix": "block",
		"body": [
			"struct Block {",
			"    int siz, n;",
			"    vector<int> ls, rs;",
			"    vector<bool> is;",
			"",
			"    explicit Block(int n_) : siz(std::round(std::sqrt(n_))), n((n_ + siz - 1) / siz) {",
			"        ls.resize(n);",
			"        rs.resize(n);",
			"        is.assign(n, false);",
			"        for (int i = 0; i < n; ++i) {",
			"            ls[i] = siz * i;",
			"            rs[i] = (i + 1 == n ? n_ : siz * (i + 1));",
			"        }",
			"    }",
			"",
			"    template <typename T>",
			"    void small_update(int idx, T val);",
			"",
			"    template <typename T>",
			"    void big_update(int idx, T val);",
			"",
			"    template <typename T>",
			"    void update(int l, int r, T val) {",
			"        if (r <= l) return;",
			"        int b_l = l / siz, b_r = (r - 1) / siz;",
			"        if (b_l < b_r) {",
			"            if (l == ls[b_l])  big_update(b_l, val);",
			"            else for (int i = l; i < rs[b_l]; ++i)  small_update(i, val);",
			"            for (int i = b_l + 1; i < b_r; ++i)  big_update(i, val);",
			"            if (r == rs[b_r])  big_update(b_r, val);",
			"            else  for (int i = ls[b_r]; i < r; ++i)   small_update(i, val);",
			"        } else {",
			"            for (int i = l; i < r; ++i)  small_update(i, val);",
			"        }",
			"    }",
			"",
			"    template <typename T>",
			"    void small_query(int idx, T& val);",
			"",
			"    template <typename T>",
			"    void big_query(int idx, T& val);",
			"",
			"    template <typename T>",
			"    T query(int l, int r, T id) {",
			"        int b_l = l / siz, b_r = (r - 1) / siz;",
			"        T res = id;",
			"        if (b_l < b_r) {",
			"            if (l == ls[b_l])  big_query(b_l, res);",
			"            else for (int i = l; i < rs[b_l]; ++i) small_query(i, res);",
			"            for (int i = b_l + 1; i < b_r; ++i)  big_query(i, res);",
			"            if (r == rs[b_r])  big_query(b_r, res);",
			"            else  for (int i = ls[b_r]; i < r; ++i) small_query(i, res);",
			"        } else {",
			"            for (int i = l; i < r; ++i)  small_query(i, res);",
			"        }",
			"        return res;",
			"    }",
			"};",
			"vector<ll> a, b, lazy;",
			"",
			"template <typename T>",
			"void Block::small_update(int idx, T val) {",
			"    a[idx] += val;",
			"    b[idx / siz] += val;",
			"}",
			"",
			"template <typename T>",
			"void Block::big_update(int idx, T val) {",
			"    lazy[idx] += val;",
			"    is[idx] = true;",
			"}",
			"",
			"template <typename T>",
			"void Block::small_query(int idx, T& val) {",
			"    int big_idx = idx / siz;",
			"    if (is[big_idx]) {",
			"        for (int i = ls[big_idx]; i < rs[big_idx]; ++i) {",
			"            small_update(i, lazy[big_idx]);",
			"        }",
			"        lazy[big_idx] = 0;",
			"        is[big_idx] = false;",
			"    }",
			"    val += a[idx];",
			"}",
			"",
			"template <typename T>",
			"void Block::big_query(int idx, T& val) {",
			"    val += b[idx] + lazy[idx] * (rs[idx] - ls[idx]);",
			"}",
			"",
			"void solve() {",
			"    int n;",
			"    cin >> n;",
			"    a.resize(n + 1), b.resize(n + 1), lazy.resize(n + 1);",
			"    Block block(n + 1);",
			"    for (int i = 1; i <= n; i++) {",
			"        cin >> a[i];",
			"        b[i / block.siz] += a[i];",
			"    }",
			"    int q = n;",
			"    while (q--) {",
			"        int op;",
			"        cin >> op;",
			"        int l, r, c;",
			"        cin >> l >> r >> c;",
			"        if (op == 0) {",
			"            block.update(l, r + 1, c);",
			"        } else {",
			"            ll ans = 0;",
			"            cout << block.query(l, r + 1, ans) % (c + 1) << endl;",
			"        }",
			"    }",
			"}"
		],
		"description": "Block 模板用于分块处理任务"
	},
	"PresidentTree Template": {
		"scope": "cpp",
		"prefix": "ptree",
		"body": [
			"struct PresidentTree {",
			"    #define mid ((l+r)>>1)",
			"    struct node {",
			"        int l, r;",
			"        int cnt;",
			"    };",
			"    int cnt, n;",
			"    vector<int> rt;   ",
			"    vector<node> tr;   ",
			"    PresidentTree(int n, int q) {",
			"        tr.resize(4 * n + 2 * (log(n) + 1) * q + 500);",
			"        rt.resize(n + 1);",
			"        this->n = n;",
			"        cnt = 0;",
			"    }",
			"",
			"    void modify(int& u, int v, int l, int r, int x) {",
			"        u = ++cnt;",
			"        tr[u] = tr[v];",
			"        tr[u].cnt++;",
			"        if (l == r) return;",
			"        if (x <= mid) modify(tr[u].l, tr[v].l, l, mid, x);",
			"        else modify(tr[u].r, tr[v].r, mid + 1, r, x);",
			"    }",
			"",
			"    void modify(int u, int v, int x) {",
			"        modify(rt[u], rt[v], 0, n - 1, x);",
			"    }",
			"",
			"    int kth(int u, int v, int l, int r, int k) {",
			"        if (l == r) return l;",
			"        int c = tr[tr[v].l].cnt - tr[tr[u].l].cnt; ",
			"        int m = (l + r) >> 1;",
			"        if (k <= c) return kth(tr[u].l, tr[v].l, l, m, k);",
			"        else return kth(tr[u].r, tr[v].r, m + 1, r, k - c);",
			"    }",
			"",
			"    int kth(int l, int r, int k) {",
			"        return kth(rt[l], rt[r], 0, n - 1, k);",
			"    }",
			"    #undef mid",
			"};"
		],
		"description": "C++ PresidentTree 模板代码"
	},
	"Comb Template": {
		"scope": "cpp",
		"prefix": "comb",
		"body": [
			"struct Comb {",
			"    int n;",
			"    std::vector<Z> _fac;",
			"    std::vector<Z> _invfac;",
			"    std::vector<Z> _inv;",
			"",
			"    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}",
			"    Comb(int n) : Comb() {",
			"        init(n);",
			"    }",
			"",
			"    void init(int m) {",
			"        if (m <= n) return;",
			"        _fac.resize(m + 1);",
			"        _invfac.resize(m + 1);",
			"        _inv.resize(m + 1);",
			"",
			"        for (int i = n + 1; i <= m; i++) {",
			"            _fac[i] = _fac[i - 1] * i;",
			"        }",
			"        _invfac[m] = _fac[m].inv();",
			"        for (int i = m; i > n; i--) {",
			"            _invfac[i - 1] = _invfac[i] * i;",
			"            _inv[i] = _invfac[i] * _fac[i - 1];",
			"        }",
			"        n = m;",
			"    }",
			"",
			"    Z fac(int m) {",
			"        if (m > n) init(2 * m);",
			"        return _fac[m];",
			"    }",
			"    Z invfac(int m) {",
			"        if (m > n) init(2 * m);",
			"        return _invfac[m];",
			"    }",
			"    Z inv(int m) {",
			"        if (m > n) init(2 * m);",
			"        return _inv[m];",
			"    }",
			"    Z binom(int n, int m) {",
			"        if (n < m || m < 0) return 0;",
			"        return fac(n) * invfac(m) * invfac(n - m);",
			"    }",
			"};",
			"Comb comb;"
		],
		"description": "C++ Comb 模板代码，用于计算组合数、阶乘与逆元"
	},
	"EDCC Template": {
		"scope": "cpp",
		"prefix": "edcc",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"typedef pair<int, int> pii;",
			"",
			"struct EDCC {",
			"    int n, now, cnt;",
			"    vector<vector<int>> g;",
			"    vector<int> dfn, low, col, S;",
			"    set<pii> bridge;",
			"",
			"    EDCC(int n) : n(n), g(n + 1), low(n + 1) {",
			"        dfn.resize(n + 1, -1);",
			"        col.resize(n + 1, -1);",
			"        now = cnt = 0;",
			"    }",
			"",
			"    void add(int u, int v) {",
			"        if (u == v) return;",
			"        g[u].push_back(v);",
			"        g[v].push_back(u);",
			"    }",
			"",
			"    void tarjan(int u, int fa) {",
			"        dfn[u] = low[u] = ++now;",
			"        S.push_back(u);",
			"        int f = 0;",
			"        for (auto v : g[u]) {",
			"            if (v == fa && !f) {",
			"                f = 1;",
			"                continue;",
			"            }",
			"            if (dfn[v] == -1) {",
			"                bridge.insert({u, v});",
			"                tarjan(v, u);",
			"                low[u] = min(low[u], low[v]);",
			"            } else if (col[v] == -1 && dfn[v] < dfn[u]) {",
			"                bridge.insert({u, v});",
			"                low[u] = min(low[u], dfn[v]);",
			"            }",
			"        }",
			"        if (dfn[u] == low[u]) {",
			"            int pre;",
			"            ++cnt;",
			"            do {",
			"                pre = S.back();",
			"                col[pre] = cnt;",
			"                S.pop_back();",
			"            } while (pre != u);",
			"        }",
			"    }",
			"",
			"    auto work() { // 返回 tuple{ cnt, adj, col, siz }",
			"        for (int i = 1; i <= n; i++) {",
			"            if (dfn[i] == -1) {",
			"                tarjan(i, 0);",
			"            }",
			"        }",
			"",
			"        vector<int> siz(cnt + 1);",
			"        vector<vector<int>> adj(cnt + 1);",
			"        for (int i = 1; i <= n; i++) {",
			"            siz[col[i]]++;",
			"            for (auto j : g[i]) {",
			"                int x = col[i], y = col[j];",
			"                if (x != y) {",
			"                    adj[x].push_back(y);",
			"                }",
			"            }",
			"        }",
			"        return tuple{ cnt, adj, col, siz };",
			"    }",
			"};",
			"",
			"void solve() {",
			"    int n, m;",
			"    cin >> n >> m;",
			"    EDCC g(n);",
			"    for (int i = 1; i <= m; i++) {",
			"        int u, v;",
			"        cin >> u >> v;",
			"        g.add(u, v);",
			"    }",
			"    g.work();",
			"    vector<vector<int>> ans(n + 1);",
			"    for (int i = 1; i <= n; i++) ans[g.col[i]].push_back(i);",
			"    int res = 0;",
			"    for (int i = 1; i <= n; i++) {",
			"        if (!ans[i].empty()) res++;",
			"    }",
			"    cout << res << endl;",
			"    for (int i = 1; i <= n; i++) {",
			"        if (!ans[i].empty()) {",
			"            cout << ans[i].size() << \" \";",
			"            for (auto v : ans[i]) cout << v << \" \";",
			"            cout << endl;",
			"        }",
			"    }",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    solve();",
			"    return 0;",
			"}"
		],
		"description": "C++ EDCC 模板代码，用于求解桥边分量及新图构造"
	},
	"HopcroftKarp Template": {
		"scope": "cpp",
		"prefix": "hk",
		"body": [
			"struct HopcroftKarp {",
			"    vector<vector<int>> e;",
			"    vector<int> pa, pb, vis;",
			"    int n, m, dfn, res;",
			"",
			"    HopcroftKarp() {}",
			"",
			"    HopcroftKarp(int n, int m) {",
			"        init(n, m);",
			"    }",
			"",
			"    void init(int _n, int _m) {",
			"        n = _n;",
			"        m = _m;",
			"        pa.assign(n + 1, -1);",
			"        pb.assign(m + 1, -1);",
			"        vis.assign(m + 1, 0);",
			"        e.resize(n + 1);",
			"        res = 0;",
			"        dfn = 0;",
			"    }",
			"",
			"    void add(int x, int y) {",
			"        e[x].push_back(y);",
			"    }",
			"",
			"    bool dfs(int u) {",
			"        for (int v : e[u]) {",
			"            if (vis[v] != dfn) {",
			"                vis[v] = dfn;",
			"                if (pb[v] == -1 || dfs(pb[v])) {",
			"                    pa[u] = v;",
			"                    pb[v] = u;",
			"                    return true;",
			"                }",
			"            }",
			"        }",
			"        return false;",
			"    }",
			"",
			"    int work() {",
			"        while (true) {",
			"            dfn++;",
			"            int cnt = 0;",
			"            for (int i = 1; i <= n; i++) {",
			"                if (pa[i] == -1 && dfs(i)) {",
			"                    cnt++;",
			"                }",
			"            }",
			"            if (cnt == 0) break;",
			"            res += cnt;",
			"        }",
			"        return res;",
			"    }",
			"};",
			"",
			"void solve() {",
			"    int n1, n2, m;",
			"    cin >> n1 >> n2 >> m;",
			"    HopcroftKarp g(n1, n2);",
			"    while (m--) {",
			"        int u, v;",
			"        cin >> u >> v;",
			"        g.add(u, v);",
			"    }",
			"    cout << g.work() << endl;",
			"}"
		],
		"description": "C++ HopcroftKarp 模板代码，用于求解二分图最大匹配"
	},
	"Max Cost Match Template": {
		"scope": "cpp",
		"prefix": "mcm",
		"body": [
			"struct MaxCostMatch {",
			"    vector<ll> ansl, ansr, pre;",
			"    vector<ll> lx, ly;",
			"    vector<vector<ll>> ver;",
			"    int n;",
			"",
			"    MaxCostMatch(int n) : n(n) {",
			"        ver.resize(n + 1, vector<ll>(n + 1, -inf));",
			"        ansl.resize(n + 1, -1);",
			"        ansr.resize(n + 1, -1);",
			"        lx.resize(n + 1);",
			"        ly.resize(n + 1, -inf);",
			"        pre.resize(n + 1);",
			"    }",
			"",
			"    void add(int x, int y, ll w) {",
			"        ver[x][y] = w;",
			"    }",
			"",
			"    void bfs(int x) {",
			"        vector<bool> visl(n + 1), visr(n + 1);",
			"        vector<ll> slack(n + 1, inf);",
			"        queue<int> q;",
			"        auto check = [&](int x) -> bool {",
			"            visr[x] = true;",
			"            if (ansr[x] != -1) {",
			"                q.push(ansr[x]);",
			"                visl[ansr[x]] = true;",
			"                return false;",
			"            }",
			"            while (x != -1) {",
			"                int tmp = ansl[pre[x]];",
			"                ansr[x] = pre[x];",
			"                ansl[pre[x]] = x;",
			"                x = tmp;",
			"            }",
			"            return true;",
			"        };",
			"",
			"        q.push(x);",
			"        visl[x] = true;",
			"        while (true) {",
			"            while (!q.empty()) {",
			"                int cur = q.front();",
			"                q.pop();",
			"                for (int y = 1; y <= n; ++y) {",
			"                    if (visr[y]) continue;",
			"                    ll del = lx[cur] + ly[y] - ver[cur][y];",
			"                    if (del < slack[y]) {",
			"                        pre[y] = cur;",
			"                        slack[y] = del;",
			"                        if (slack[y] == 0 && check(y))",
			"                            return;",
			"                    }",
			"                }",
			"            }",
			"            ll val = inf;",
			"            for (int i = 1; i <= n; ++i) {",
			"                if (!visr[i])",
			"                    val = min(val, slack[i]);",
			"            }",
			"            for (int i = 1; i <= n; ++i) {",
			"                if (visl[i]) lx[i] -= val;",
			"                if (visr[i])",
			"                    ly[i] += val;",
			"                else",
			"                    slack[i] -= val;",
			"            }",
			"            for (int i = 1; i <= n; ++i) {",
			"                if (!visr[i] && slack[i] == 0 && check(i))",
			"                    return;",
			"            }",
			"        }",
			"    }",
			"",
			"    ll work() {",
			"        for (int i = 1; i <= n; ++i) {",
			"            for (int j = 1; j <= n; ++j) {",
			"                ly[i] = max(ly[i], ver[j][i]);",
			"            }",
			"        }",
			"        for (int i = 1; i <= n; ++i)",
			"            bfs(i);",
			"        ll res = 0;",
			"        for (int i = 1; i <= n; ++i) {",
			"            res += ver[i][ansl[i]];",
			"        }",
			"        return res;",
			"    }",
			"",
			"    void getMatch(int x, int y) {",
			"        for (int i = 1; i <= x; ++i) {",
			"            cout << (ver[i][ansl[i]] ? ansl[i] : 0) << \" \";",
			"        }",
			"        cout << endl;",
			"        for (int i = 1; i <= y; ++i) {",
			"            cout << (ver[i][ansr[i]] ? ansr[i] : 0) << \" \";",
			"        }",
			"        cout << endl;",
			"    }",
			"};"
		],
		"description": "C++ Max Cost Match 模板代码，用于求解最大费用匹配问题"
	},
	"SCC Template": {
		"scope": "cpp",
		"prefix": "scc",
		"body": [
			"struct SCC {",
			"    int n, now, cnt;",
			"    vector<vector<int>> g;",
			"    vector<int> dfn, low, col, S;",
			"    SCC(int n) : n(n), g(n + 1), low(n + 1) {",
			"        dfn.resize(n + 1, -1);",
			"        col.resize(n + 1, -1);",
			"        now = cnt = 0;",
			"    }",
			"    void add(int x, int y) {",
			"        g[x].push_back(y);",
			"    }",
			"    void tarjan(int u) {",
			"        dfn[u] = low[u] = ++now;",
			"        S.push_back(u);",
			"        for (auto v : g[u]) {",
			"            if (dfn[v] == -1) {",
			"                tarjan(v);",
			"                low[u] = min(low[u], low[v]);",
			"            } else if (col[v] == -1) {",
			"                low[u] = min(low[u], dfn[v]);",
			"            }",
			"        }",
			"        if (dfn[u] == low[u]) {",
			"            int pre;",
			"            ++cnt;",
			"            do {",
			"                pre = S.back();",
			"                col[pre] = cnt;",
			"                S.pop_back();",
			"            } while (u != pre);",
			"        }",
			"    }",
			"    auto work() { // 返回 tuple{ cnt, adj, col, siz }",
			"        for (int i = 1; i <= n; i++) {",
			"            if (dfn[i] == -1) {",
			"                tarjan(i);",
			"            }",
			"        }",
			"",
			"        vector<int> siz(cnt + 1);",
			"        vector<vector<int>> adj(cnt + 1);",
			"        for (int i = 1; i <= n; i++) {",
			"            siz[col[i]]++;",
			"            for (auto j : g[i]) {",
			"                int x = col[i], y = col[j];",
			"                if (x != y) {",
			"                    adj[x].push_back(y);",
			"                }",
			"            }",
			"        }",
			"        return tuple{ cnt, adj, col, siz };",
			"    }",
			"};",
			"",
			"void solve() {",
			"    int n, m;",
			"    cin >> n >> m;",
			"    SCC g(n);",
			"    for (int i = 1; i <= m; i++) {",
			"        int u, v;",
			"        cin >> u >> v;",
			"        g.add(u, v);",
			"    }",
			"    g.work();",
			"    vector<vector<int>> ans(n + 1);",
			"    for (int i = 1; i <= n; i++)",
			"        ans[g.col[i]].push_back(i);",
			"    int res = 0;",
			"    for (int i = 1; i <= n; i++) {",
			"        if (!ans[i].empty()) res++;",
			"    }",
			"    cout << res << endl;",
			"",
			"    vector<vector<int>> t;",
			"    for (int i = 1; i <= n; i++) {",
			"        if (!ans[i].empty()) {",
			"            sort(ans[i].begin(), ans[i].end());",
			"            t.push_back(ans[i]);",
			"        }",
			"    }",
			"    sort(t.begin(), t.end(), [&](vector<int> x, vector<int> y) {",
			"        return x[0] < y[0];",
			"    });",
			"    for (auto v : t) {",
			"        for (auto x : v) cout << x << \" \";",
			"        cout << endl;",
			"    }",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    solve();",
			"    return 0;",
			"}"
		],
		"description": "C++ SCC 模板代码，用于求解有向图中的强连通分量"
	},
	"TwoSat Template": {
		"scope": "cpp",
		"prefix": "2sat",
		"body": [
			"struct TwoSat {",
			"    int n;",
			"    vector<vector<int>> e;",
			"    vector<bool> ans;",
			"    TwoSat(int n) : n(n), e(2 * n), ans(n) {}",
			"",
			"    void add(int u, bool f, int v, bool g) {",
			"        e[2 * u + !f].push_back(2 * v + g);",
			"        e[2 * v + !g].push_back(2 * u + f);",
			"    }",
			"",
			"    bool work() {",
			"        vector<int> id(2 * n, -1), dfn(2 * n, -1), low(2 * n, -1);",
			"        vector<int> stk;",
			"        int now = 0, cnt = 0;",
			"        auto tarjan = [&](auto self, int u) -> void {",
			"            stk.push_back(u);",
			"            dfn[u] = low[u] = now++;",
			"            for (auto v : e[u]) {",
			"                if (dfn[v] == -1) {",
			"                    self(self, v);",
			"                    low[u] = min(low[u], low[v]);",
			"                } else if (id[v] == -1) {",
			"                    low[u] = min(low[u], dfn[v]);",
			"                }",
			"            }",
			"            if (dfn[u] == low[u]) {",
			"                int v;",
			"                do {",
			"                    v = stk.back();",
			"                    stk.pop_back();",
			"                    id[v] = cnt;",
			"                } while (v != u);",
			"                ++cnt;",
			"            }",
			"        };",
			"        for (int i = 0; i < 2 * n; ++i) {",
			"            if (dfn[i] == -1) {",
			"                tarjan(tarjan, i);",
			"            }",
			"        }",
			"        for (int i = 0; i < n; ++i) {",
			"            if (id[2 * i] == id[2 * i + 1]) return false;",
			"            ans[i] = id[2 * i] > id[2 * i + 1];",
			"        }",
			"        return true;",
			"    }",
			"",
			"    vector<bool> answer() {",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "C++ TwoSat 模板代码，用于求解 2-SAT 问题"
	},
	"VDCC Template": {
		"scope": "cpp",
		"prefix": "vdcc",
		"body": [
			"struct VDCC {",
			"    int n;",
			"    vector<vector<int>> g, col;",
			"    vector<int> dfn, low, S;",
			"    int now, cnt;",
			"    vector<bool> point;",
			"    VDCC(int n) : n(n) {",
			"        g.resize(n + 1);",
			"        col.resize(2 * n + 1);",
			"        dfn.resize(n + 1);",
			"        low.resize(n + 1);",
			"        S.clear();",
			"        point.resize(n + 1);",
			"        now = 0, cnt = 0;",
			"    }",
			"",
			"    void add(int u, int v) {",
			"        if (u == v) return;",
			"        g[u].push_back(v);",
			"        g[v].push_back(u);",
			"    }",
			"",
			"    void tarjan(int u, int root) {",
			"        low[u] = dfn[u] = ++now;",
			"        S.push_back(u);",
			"        if (u == root && g[u].empty()) {",
			"            ++cnt;",
			"            col[cnt].push_back(u);",
			"            return;",
			"        }",
			"        int flag = 0;",
			"        for (auto v : g[u]) {",
			"            if (!dfn[v]) {",
			"                tarjan(v, root);",
			"                low[u] = min(low[u], low[v]);",
			"                if (dfn[u] <= low[v]) {",
			"                    flag++;",
			"                    if (flag > 1 || u != root) point[u] = true;",
			"                    int pre = 0;",
			"                    ++cnt;",
			"                    do {",
			"                        pre = S.back();",
			"                        col[cnt].push_back(pre);",
			"                        S.pop_back();",
			"                    } while (pre != v);",
			"                    col[cnt].push_back(u);",
			"                }",
			"            } else {",
			"                low[u] = min(low[u], dfn[v]);",
			"            }",
			"        }",
			"    }",
			"",
			"    pair<int, vector<vector<int>>> rebuild() {",
			"        work();",
			"        vector<vector<int>> adj(cnt + 1);",
			"        for (int i = 1; i <= cnt; i++) {",
			"            if (!col[i].size()) continue;",
			"            for (auto j : col[i]) {",
			"                if (point[j]) {",
			"                    adj[i].push_back(point[j]);",
			"                    adj[point[j]].push_back(i);",
			"                }",
			"            }",
			"        }",
			"        return { cnt, adj };",
			"    }",
			"",
			"    void work() {",
			"        for (int i = 1; i <= n; i++) {",
			"            if (!dfn[i]) tarjan(i, i);",
			"        }",
			"    }",
			"};",
			"",
			"void solve() {",
			"    int n, m;",
			"    cin >> n >> m;",
			"    VDCC g(n);",
			"    for (int i = 1; i <= m; i++) {",
			"        int u, v;",
			"        cin >> u >> v;",
			"        g.add(u, v);",
			"    }",
			"",
			"    g.work();",
			"    int ans = 0;",
			"    for (int i = 1; i <= g.cnt; i++) {",
			"        if (!g.col[i].empty()) ans++;",
			"    }",
			"    cout << ans << endl;",
			"    for (int i = 1; i <= g.cnt; i++) {",
			"        if (!g.col[i].empty()) {",
			"            cout << g.col[i].size() << \" \";",
			"            for (auto v : g.col[i]) cout << v << \" \";",
			"            cout << endl;",
			"        }",
			"    }",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    solve();",
			"    return 0;",
			"}"
		],
		"description": "C++ VDCC 模板代码，用于桥边分量及新图的构造"
	},
	"StringHash Template": {
		"scope": "cpp",
		"prefix": "strhash",
		"body": [
			"class stringhash {",
			"public:",
			"    std::vector<ll> h1, h2, p1, p2;",
			"    ll base1 = 114514, base2 = 54321, mod1 = 1610612741, mod2 = 1004535809;",
			"",
			"    void init(std::string s) {",
			"        int n = s.size();",
			"        s = \" \" + s;",
			"        h1.resize(n + 1), h2.resize(n + 1);",
			"        p1.resize(n + 1), p2.resize(n + 1);",
			"        h1[0] = h2[0] = 0;",
			"        p1[0] = p2[0] = 1;",
			"        for (int i = 1; i <= n; i++) {",
			"            h1[i] = (h1[i - 1] * base1 + s[i]) % mod1;",
			"            p1[i] = p1[i - 1] * base1 % mod1;",
			"            h2[i] = (h2[i - 1] * base2 + s[i]) % mod2;",
			"            p2[i] = p2[i - 1] * base2 % mod2;",
			"        }",
			"    }",
			"",
			"    std::pair<ll, ll> get(int l, int r) {",
			"        return { ((h1[r] - h1[l - 1] * p1[r - l + 1] % mod1) + mod1) % mod1,",
			"                 ((h2[r] - h2[l - 1] * p2[r - l + 1] % mod2) + mod2) % mod2 };",
			"    }",
			"};"
		],
		"description": "C++ stringhash 模板代码，用于字符串哈希"
	},
}